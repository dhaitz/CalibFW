#pragma once

#include <vector>
#include <sstream>

#include <boost/noncopyable.hpp>
#include <boost/ptr_container/ptr_vector.hpp>

#include "FilterBase.h"

namespace Artus
{

template<class TData, class TProduct, class TSettings>
class EventPipeline;

/*
	The base class to implement your own EventConsumer which run within an EventPipeline.
	This class gets the FilterResult, the created meta data, the settings and the input event ifself
	and can create the output you desire.
	It is not allowed to write to the settings, filer, event and meta data.

 */

template<class TData, class TProduct, class TSettings>
class EventConsumerBase: public boost::noncopyable
{
public:
	virtual ~EventConsumerBase()
	{
	}

	/*
	 * Called before the first Event is passed to this consumer
	 */
	virtual void Init(EventPipeline<TData, TProduct, TSettings>* pipeline)
	{
		m_pipeline = pipeline;
	}


	/* this method is only called for events which have passed the filter imposed on the
	 * pipeline
	 */
	virtual void ProcessFilteredEvent(TData const& event,
									  TProduct const& product)
	{
	}

	/*
	 *  this method is called for all events
	 */
	virtual void ProcessEvent(TData const& event, TProduct const& product,
							  FilterResult& result)
	{
	}

	/*
	 *  this method is called for pipeline which do not operate on event input but on data
	 *  generated by preceeding pipelines
	 */
	virtual void Process()
	{
	}

	/*
	 * Called after the last event. Overwire this to store your histograms etc. to disk
	 */
	virtual void Finish() = 0;

	/*
	 * Must return a unique id of the EventConsumer.
	 */
	virtual std::string GetId() const
	{
		return "default";
	}

	/*
	 * Return a reference to the settings used for this consumer
	 */
	TSettings const& GetPipelineSettings() const
	{
		return this->m_pipeline->GetSettings();
	}

protected:
	EventPipeline<TData, TProduct, TSettings>* m_pipeline;
};


}
